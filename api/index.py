from flask import Flask, request, send_file, jsonify
from flask_cors import CORS
import tempfile
import numpy as np
from PIL import Image, ImageDraw, ImageFont
import io
import os
import re

app = Flask(__name__)
CORS(app)

def generate_gfx_font(font_path, font_name_in, font_size, charset):
    """
    Generates an Adafruit GFX font header file from a TTF font.

    This corrected version fixes bitmap packing (MSB-first), yOffset calculation,
    and uses dynamic names for the font data structures in the C output.

    Args:
        font_path (str): Path to the .ttf font file.
        font_name_in (str): The base name for the font variables in the C header.
        font_size (int): The font size to generate.
        charset (str): A string containing all characters to include.

    Returns:
        str: The content of the generated .h file.
    """
    # Sanitize the font name to be a valid C identifier
    font_name = re.sub(r'\W|^(?=\d)', '_', font_name_in)

    font = ImageFont.truetype(font_path, font_size)
    gfx_output = io.StringIO()

    # Get global font metrics
    ascent, descent = font.getmetrics()
    y_advance = ascent + descent

    # --- C Header Generation ---
    gfx_output.write(f"// Font data for {font_name} {font_size}pt\n")
    gfx_output.write(f"// Generated by a Flask-based GFX Font Generator\n\n")
    gfx_output.write("#include <Adafruit_GFX.h>\n\n")

    bitmaps = bytearray()
    glyphs = []
    
    # GFX fonts require a contiguous range of characters
    first_char_code = ord(charset[0])
    last_char_code = ord(charset[-1])

    bitmap_offset = 0

    # --- Glyph and Bitmap Generation Loop ---
    for char_code in range(first_char_code, last_char_code + 1):
        char = chr(char_code)
        
        # Skip characters that are not in the requested charset but are in the range
        if char not in charset:
            glyphs.append({ 'bitmapOffset': bitmap_offset, 'width': 0, 'height': 0, 'xAdvance': 0, 'xOffset': 0, 'yOffset': 0, 'char': char})
            continue

        # Get the bounding box of the character
        try:
            bbox = font.getbbox(char)
        except TypeError: # Handle potential Pillow version inconsistencies
            bbox = None

        if bbox is None:
            # Handle characters with no visual representation (like space)
            width, height, x_offset, y_offset_top = 0, 0, 0, 0
            # Use width of a standard character like 'a' as a heuristic for space's advance
            x_advance = int(font.getlength("a") / 2)
            bitmap_byte_count = 0
        else:
            left, top, right, bottom = bbox
            width = right - left
            height = bottom - top
            x_offset = left
            y_offset_top = top

            # Create a 1-bit mask image for the character
            mask = Image.new("1", (width, height))
            draw = ImageDraw.Draw(mask)
            # Draw character, offsetting it to the top-left of the mask
            draw.text((-left, -top), char, font=font, fill=1)

            # Convert mask to a numpy array for easy pixel access
            bitmap_np = np.array(mask).astype(np.uint8)
            
            char_bitmap_bytes = bytearray()
            # --- Correct Bitmap Packing (MSB-First) ---
            # This was the primary source of visual corruption in the original code.
            for y in range(height):
                for x_byte in range((width + 7) // 8):
                    byte = 0
                    for x_bit in range(8):
                        x = x_byte * 8 + x_bit
                        if x < width:
                            if bitmap_np[y, x]:
                                byte |= 1 << (7 - x_bit) # Pack bits MSB-first
                    char_bitmap_bytes.append(byte)
            
            bitmaps.extend(char_bitmap_bytes)
            bitmap_byte_count = len(char_bitmap_bytes)
            x_advance = int(font.getlength(char))

        # --- GFX Glyph Struct Population ---
        glyphs.append({
            'bitmapOffset': bitmap_offset,
            'width': width, 
            'height': height,
            'xAdvance': x_advance,
            'xOffset': x_offset,
            # Correct yOffset calculation: distance from baseline to top of char bitmap.
            # A positive value moves the bitmap down from the baseline.
            'yOffset': (ascent - y_offset_top) if bbox else 0,
            'char': char
        })
        bitmap_offset += bitmap_byte_count
        
    # --- Write Bitmaps Array to File ---
    gfx_output.write(f"const uint8_t {font_name}Bitmaps[] PROGMEM = {{\n  ")
    if bitmaps:
        for i, byte in enumerate(bitmaps):
            gfx_output.write(f"0x{byte:02X}, ")
            if i > 0 and (i + 1) % 16 == 0:
                gfx_output.write("\n  ")
        gfx_output.write("\n")
    gfx_output.write("};\n\n")

    # --- Write Glyphs Array to File ---
    gfx_output.write(f"const GFXglyph {font_name}Glyphs[] PROGMEM = {{\n")
    for i, g in enumerate(glyphs):
        char_escaped = g['char'].replace('\\', '\\\\').replace("'", "\\'")
        gfx_output.write(
            f"  {{ {g['bitmapOffset']:4d}, {g['width']:2d}, {g['height']:2d}, {g['xAdvance']:2d}, "
            f"{g['xOffset']:3d}, {g['yOffset']:3d} }}, // 0x{first_char_code + i:02X} '{char_escaped}'\n"
        )
    gfx_output.write("};\n\n")

    # --- Write Font Struct to File ---
    gfx_output.write(f"const GFXfont {font_name} PROGMEM = {{\n")
    gfx_output.write(f"  (uint8_t  *){font_name}Bitmaps,\n")
    gfx_output.write(f"  (GFXglyph *){font_name}Glyphs,\n")
    gfx_output.write(f"  0x{first_char_code:02X}, 0x{last_char_code:02X}, {y_advance}\n")
    gfx_output.write("};\n")

    return gfx_output.getvalue()

@app.route('/generate_gfx', methods=['POST'])
def generate_gfx_route():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected for uploading'}), 400
        
    font_size_str = request.form.get('size')
    if not font_size_str:
        return jsonify({'error': 'No font size provided in form data'}), 400
        
    try:
        font_size = int(font_size_str)
        if font_size <= 0:
            raise ValueError
    except ValueError:
        return jsonify({'error': 'Invalid font size provided'}), 400
        
    # Generate a C-compatible name from the font file name.
    base_filename = os.path.splitext(file.filename)[0]
    font_name = f"{base_filename}{font_size}pt"
    output_filename = f"{re.sub(r'\\W|^(?=\\d)', '_', font_name)}.h"

    # Using temporary files is a reliable way to handle uploads
    with tempfile.NamedTemporaryFile(delete=True, suffix='.ttf') as temp_font:
        file.save(temp_font.name)
        try:
            # Define the character set to include in the font
            charset = ''.join([chr(i) for i in range(32, 127)]) # Standard ASCII
            
            gfx_content = generate_gfx_font(temp_font.name, font_name, font_size, charset)

            # Use an in-memory BytesIO buffer to send the file content
            output_buffer = io.BytesIO(gfx_content.encode('utf-8'))
            output_buffer.seek(0)
            
            return send_file(
                output_buffer,
                mimetype='text/x-c',
                as_attachment=True,
                download_name=output_filename
            )
        except Exception as e:
            import traceback
            traceback.print_exc() # Log the full error to the server console
            return jsonify({'error': f'Failed to process font: {str(e)}'}), 500
