from flask import Flask, request, send_file, jsonify
from flask_cors import CORS
import tempfile
import numpy as np
from PIL import Image, ImageDraw, ImageFont
import io
import os
import re

app = Flask(__name__)
CORS(app)

def generate_gfx_font(font_path, font_name_in, font_size, charset):
    """
    Generates an Adafruit GFX font header file from a TTF font.

    This corrected version uses font.getmask() for robust bitmap generation
    and corrects the yOffset calculation to fix rendering artifacts.

    Args:
        font_path (str): Path to the .ttf font file.
        font_name_in (str): The base name for the font variables in the C header.
        font_size (int): The font size to generate.
        charset (str): A string containing all characters to include.

    Returns:
        str: The content of the generated .h file.
    """
    # Sanitize the font name to be a valid C identifier
    font_name = re.sub(r'\W|^(?=\d)', '_', font_name_in)

    font = ImageFont.truetype(font_path, font_size)
    gfx_output = io.StringIO()

    # Get global font metrics. Ascent is distance from baseline to top.
    # y_advance is the recommended line spacing.
    ascent, descent = font.getmetrics()
    y_advance = ascent + descent

    # --- C Header Generation ---
    gfx_output.write(f"// Font data for {font_name} {font_size}pt\n")
    gfx_output.write(f"// Generated by a Flask-based GFX Font Generator\n\n")
    gfx_output.write("#include <Adafruit_GFX.h>\n\n")

    bitmaps = bytearray()
    glyphs = []
    
    first_char_code = ord(charset[0])
    last_char_code = ord(charset[-1])

    bitmap_offset = 0

    # --- Glyph and Bitmap Generation Loop ---
    for char_code in range(first_char_code, last_char_code + 1):
        char = chr(char_code)
        
        # GFX Fonts require a continuous block of characters.
        # If a character is missing, we add a placeholder glyph.
        if char not in charset:
            glyphs.append({'bitmapOffset': bitmap_offset, 'width': 0, 'height': 0, 'xAdvance': 0, 'xOffset': 0, 'yOffset': 0, 'char': char})
            continue
        
        # --- FIX: Derive dimensions directly from the numpy bitmap array ---
        # This prevents "out of bounds" errors by ensuring the loop bounds
        # always match the array being indexed.
        width, height, x_offset, y_offset_top = 0, 0, 0, 0
        bitmap_np = None

        try:
            # Get the character's bitmap mask
            mask = font.getmask(char, mode='1')
            # Convert mask to a numpy array, which is the authoritative source
            bitmap_np = np.array(mask).astype(np.uint8)
            
            # Reshape 1D arrays (from 1-pixel-high chars) to 2D
            if bitmap_np.ndim == 1:
                bitmap_np = np.reshape(bitmap_np, (1, -1))
            
            # Get dimensions directly from the final numpy array's shape
            height, width = bitmap_np.shape
            
            # Get the bounding box to find offsets
            bbox = font.getbbox(char)
            x_offset = bbox[0]
            y_offset_top = bbox[1]
        except (TypeError, AttributeError):
            # This handles non-rendering characters like 'space'
            width, height, x_offset, y_offset_top = 0, 0, 0, 0
            bitmap_np = None

        # Horizontal advance is the distance to move the cursor for the next char
        try:
            x_advance = int(font.getlength(char))
        except Exception:
             x_advance = width + x_offset if width > 0 else int(font.getlength("a") / 2)

        bitmap_byte_count = 0
        if bitmap_np is not None:
            char_bitmap_bytes = bytearray()
            # --- Pack bitmap into bytes, MSB-first ---
            for y in range(height):
                for x_byte in range((width + 7) // 8):
                    byte = 0
                    for x_bit in range(8):
                        x = x_byte * 8 + x_bit
                        if x < width:
                            # In the mask, a non-zero value means the pixel is set.
                            if bitmap_np[y, x]:
                                byte |= 1 << (7 - x_bit)
                    char_bitmap_bytes.append(byte)
            
            bitmaps.extend(char_bitmap_bytes)
            bitmap_byte_count = len(char_bitmap_bytes)

        # --- GFX Glyph Struct Population ---
        glyphs.append({
            'bitmapOffset': bitmap_offset,
            'width': width, 
            'height': height,
            'xAdvance': x_advance,
            'xOffset': x_offset,
            'yOffset': -y_offset_top if height > 0 else 0,
            'char': char
        })
        bitmap_offset += bitmap_byte_count
        
    # --- Write Bitmaps Array to File ---
    gfx_output.write(f"const uint8_t {font_name}Bitmaps[] PROGMEM = {{\n  ")
    if bitmaps:
        for i, byte in enumerate(bitmaps):
            gfx_output.write(f"0x{byte:02X}, ")
            if i > 0 and (i + 1) % 16 == 0:
                gfx_output.write("\n  ")
        gfx_output.write("\n")
    gfx_output.write("};\n\n")

    # --- Write Glyphs Array to File ---
    gfx_output.write(f"const GFXglyph {font_name}Glyphs[] PROGMEM = {{\n")
    for i, g in enumerate(glyphs):
        char_escaped = g['char'].replace('\\', '\\\\').replace("'", "\\'")
        gfx_output.write(
            f"  {{ {g['bitmapOffset']:4d}, {g['width']:2d}, {g['height']:2d}, {g['xAdvance']:2d}, "
            f"{g['xOffset']:3d}, {g['yOffset']:3d} }}, // 0x{first_char_code + i:02X} '{char_escaped}'\n"
        )
    gfx_output.write("};\n\n")

    # --- Write Font Struct to File ---
    gfx_output.write(f"const GFXfont {font_name} PROGMEM = {{\n")
    gfx_output.write(f"  (uint8_t  *){font_name}Bitmaps,\n")
    gfx_output.write(f"  (GFXglyph *){font_name}Glyphs,\n")
    gfx_output.write(f"  0x{first_char_code:02X}, 0x{last_char_code:02X}, {y_advance}\n")
    gfx_output.write("};\n")

    return gfx_output.getvalue()

@app.route('/generate_gfx', methods=['POST'])
def generate_gfx_route():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected for uploading'}), 400
        
    font_size_str = request.form.get('size')
    if not font_size_str:
        return jsonify({'error': 'No font size provided in form data'}), 400
        
    try:
        font_size = int(font_size_str)
        if font_size <= 0:
            raise ValueError
    except ValueError:
        return jsonify({'error': 'Invalid font size provided'}), 400
        
    # Generate a C-compatible name from the font file name.
    base_filename = os.path.splitext(file.filename)[0]
    font_name = f"{base_filename}{font_size}pt"
    output_filename = f"{re.sub(r'\\W|^(?=\\d)', '_', font_name)}.h"

    # Using temporary files is a reliable way to handle uploads
    with tempfile.NamedTemporaryFile(delete=True, suffix='.ttf') as temp_font:
        file.save(temp_font.name)
        try:
            # Define the character set to include in the font
            charset = ''.join([chr(i) for i in range(32, 127)]) # Standard ASCII
            
            gfx_content = generate_gfx_font(temp_font.name, font_name, font_size, charset)

            # Use an in-memory BytesIO buffer to send the file content
            output_buffer = io.BytesIO(gfx_content.encode('utf-8'))
            output_buffer.seek(0)
            
            return send_file(
                output_buffer,
                mimetype='text/x-c',
                as_attachment=True,
                download_name=output_filename
            )
        except Exception as e:
            import traceback
            traceback.print_exc() # Log the full error to the server console
            return jsonify({'error': f'Failed to process font: {str(e)}'}), 500
